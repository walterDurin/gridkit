Before you start with custom index I suggest you to study this topic in Coherence documentation - [Queering data in Cache](http://download.oracle.com/docs/cd/E15357_01/coh.360/e15723/api_querycache.htm).

# Implementing custom index #
Implementing custom index requires implemeting 3 classes.
  * [IndexAwareExtractor](http://download.oracle.com/docs/cd/E15357_01/coh.360/e15725/com/tangosol/util/extractor/IndexAwareExtractor.html) is responsible for creation of index.
  * [MapIndex](http://download.oracle.com/docs/cd/E15357_01/coh.360/e15725/com/tangosol/util/MapIndex.html) implementation is core of your custom index; Coherence will notify it about changes in stored objects.
  * [IndexAwareFilter](http://download.oracle.com/docs/cd/E15357_01/coh.360/e15725/com/tangosol/util/filter/IndexAwareFilter.html) to use own index implementation you should create own filter (because standard filters are not aware about your custom index).

In Coherence [IndexAwareFilter](http://download.oracle.com/docs/cd/E15357_01/coh.360/e15725/com/tangosol/util/filter/IndexAwareFilter.html) implementation is responsible to build own execution plan. Up on execution [IndexAwareFilter](http://download.oracle.com/docs/cd/E15357_01/coh.360/e15725/com/tangosol/util/filter/IndexAwareFilter.html) is provided by collection of all indexes available for cache and it can choose which of them to use. Collection of indexes is stored as map there [ValueExtractor](http://download.oracle.com/docs/cd/E15357_01/coh.360/e15725/index.html?com/tangosol/util/extractor/IndexAwareExtractor.html) serves as key and[MapIndex](http://download.oracle.com/docs/cd/E15357_01/coh.360/e15725/com/tangosol/util/MapIndex.html) instance as value. So your custom filter should look for your custom[MapIndex](http://download.oracle.com/docs/cd/E15357_01/coh.360/e15725/com/tangosol/util/MapIndex.html) using your custom [IndexAwareExtractor](http://download.oracle.com/docs/cd/E15357_01/coh.360/e15725/com/tangosol/util/extractor/IndexAwareExtractor.html) as key (then it can downcast it and use your custom API instead of[MapIndex](http://download.oracle.com/docs/cd/E15357_01/coh.360/e15725/com/tangosol/util/MapIndex.html)).

Custom index is created same way as standard index, by calling [addIndex(…)](http://download.oracle.com/docs/cd/E15357_01/coh.360/e15725/com/tangosol/util/QueryMap.html#addIndex_com_tangosol_util_ValueExtractor__boolean__java_util_Comparator_) on cache object. If you provide [IndexAwareExtractor](http://download.oracle.com/docs/cd/E15357_01/coh.360/e15725/com/tangosol/util/extractor/IndexAwareExtractor.html) to [addIndex(…)](http://download.oracle.com/docs/cd/E15357_01/coh.360/e15725/com/tangosol/util/QueryMap.html#addIndex_com_tangosol_util_ValueExtractor__boolean__java_util_Comparator_) call, instead of creating standard [SimpleMapIndex](http://download.oracle.com/docs/cd/E15357_01/coh.360/e15725/index.html?com/tangosol/util/extractor/IndexAwareExtractor.html), Coherence will use extractor to create index structure.

# Quirks #

Different Coherence cache types are supporting indexes. Most of them are operating with keys and value as with java objects, but distributed cache is different. Distributed cache is storing all objects in binary (serialized) form internally. Filter should operate with native representation of key used by cache. This means what[MapIndex](http://download.oracle.com/docs/cd/E15357_01/coh.360/e15725/com/tangosol/util/MapIndex.html) should keep keys in [Binary](http://download.oracle.com/docs/cd/E15357_01/coh.360/e15725/com/tangosol/util/Binary.html) form id it is used with distributed cache, but with object keys in other cases. This is not hard to implement but a bit awkward.

Coherence updates index entry by entry. Many sophisticated indexes (e.g. full text indexes) are very inefficient with small updates. So you probably will want to implement some kind of delayed index updates. This way you can collect a batch of updates and safe intermediate index rebuilds.